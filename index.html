<!DOCTYPE html>
<html>

<head>
    <title>WebGL</title>
    <link rel="icon" href="./assets/favicon.png" type="image/x-icon">
    <style>
        body {
            margin: 0;
            background-color: #272727;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas" width="640" height="480"></canvas>
    <script src="./src/log.js"></script>
    <script src="./src/assets-loader.js"></script>
    <script src="./src/math.js"></script>
    <script src="./src/gl.js"></script>
    <script src="./src/glsl.js"></script>
    <script src="./src/geometry.js"></script>
    <script src="./src/orthogonal-space.js"></script>
    <script src="./src/utils.js"></script>
    <script src="./src/mouse-events.js"></script>
    <script src="./src/space-controller.js"></script>
    <script src="./src/camera.js"></script>
    <script src="./src/frustum.js"></script>
    <script src="./src/mesh.js"></script>
    <script src="./glsl/fade-away-from-camera.js"></script>
    <script src="./glsl/only-texture.js"></script>
    <script>
        const _loader = CG.createResourceLoader("./assets/");
        _loader.loadTexture("uv-grid.webp").then((image) => {
            _texture.updateData(image, 0, 0, image.width, image.height);
        });
        const {gl, canvas} = CG.createGlContext('glcanvas');
        const _tempMat44 = new CG.Mat44();
        const _camera = new CG.Camera(0, 2, 14)
            .setMouseEvents(CG.registMouseEvents(canvas))
            .setFrustum(new CG.Frustum().createPerspectiveProjection(CG.Utils.deg2Rad(60), 640 / 480, 0.1, 1000))
            .lookAt(CG.Vec4.VEC4_0001);

        const _defaultFBO = new CG.glWrapper.Framebuffer(gl, false);
        const _renderer = new CG.glWrapper.Renderer(gl);





        //--------------------------------------------------------------------------------
        const _programFadeAway = new CG.glWrapper.Program(gl, CG.shaderSource.fadeAwayFromCamera.vs, CG.shaderSource.fadeAwayFromCamera.fs);
        const _meshGrid = new CG.Mesh(CG.Geometry.createGridPlane(100, 1).init(gl));
        const _pipe_grid = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setProgram(_programFadeAway)
            .setVAO(_meshGrid.VAO)
            .setUniformUpdater({
                updateu_mvpMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewProjectionMatrix._dataArr32);
                },
                updateu_mvMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewMatrix._dataArr32);
                }
            })
            .cullFace(true)
            .setDrawArraysParameters(gl.LINES, 0, _meshGrid.vertexDataLengthInFloat)
            .validate();




        //--------------------------------------------------------------------------------
        const _program = new CG.glWrapper.Program(gl, CG.shaderSource.onlyTexture.vs, CG.shaderSource.onlyTexture.fs);
        const _mesh = new CG.Mesh(CG.Geometry.createPlane(4, 3).init(gl)).setPosition(0, 0, 0);
        const _texture = new CG.glWrapper.Texture(gl).createGLTextureWithSize(1024, 1024);

        const _pipe_cube = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setProgram(_program)
            .setVAO(_mesh.VAO)
            .setUniformUpdater(
                {
                    updateu_texture: (uLoc) => {
                        gl.uniform1i(uLoc, _texture.textureUnit);
                    },
                    updateu_mvpMatrix: (uLoc) => {
                        _mesh.cascade(_camera.viewProjectionMatrix, _tempMat44);
                        gl.uniformMatrix4fv(uLoc, false, _tempMat44._dataArr32);
                    },
                })
            .setDrawElementsParameters(gl.TRIANGLES, _mesh.numberIndices, gl.UNSIGNED_SHORT, 0)
            .setTextures(_texture)
            .cullFace(false)
            .validate();
        _renderer.addPipeline(_pipe_grid, _pipe_cube);
        //--------------------------------------------------------------------------------





        function render() {
            _camera.update();
            _renderer.render();
            requestAnimationFrame(render);
        }

        render();

    </script>
</body>

</html>
