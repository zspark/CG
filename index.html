<!DOCTYPE html>
<html>

<head>
    <title>WebGL</title>
    <link rel="icon" href="./assets/favicon.png" type="image/x-icon">
    <style>
        body {
            margin: 0;
            background-color: #272727;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas" width="640" height="480"></canvas>
    <img id="color-texture" src="./assets/uv-grid.webp" crossOrigin="anonymous"></img>
    <script src="./src/log.js"></script>
    <script src="./src/math.js"></script>
    <script src="./src/gl.js"></script>
    <script src="./src/glsl.js"></script>
    <script src="./src/geometry.js"></script>
    <script src="./src/orthogonal-space.js"></script>
    <script src="./src/utils.js"></script>
    <script src="./src/mouse-events.js"></script>
    <script src="./src/space-controller.js"></script>
    <script src="./src/camera.js"></script>
    <script src="./src/frustum.js"></script>
    <script src="./src/mesh.js"></script>
    <script src="./glsl/fade-away-from-camera.js"></script>
    <script src="./glsl/gouraud.js"></script>
    <script>
        const _imgElement = document.getElementById("color-texture"); _imgElement.remove();
        const {gl, canvas} = CG.createGlContext('glcanvas');
        const _tempMat44 = new CG.Mat44();
        const _camera = new CG.Camera(0, 2, 14)
            .setMouseEvents(CG.registMouseEvents(canvas))
            .setFrustum(new CG.Frustum().createPerspectiveProjection(CG.Utils.deg2Rad(60), 640 / 480, 0.1, 1000))
            .lookAt(CG.Vec4.VEC4_0001);

        const _defaultFBO = new CG.glWrapper.Framebuffer(gl, false);
        const _renderer = new CG.glWrapper.Renderer(gl);





        //--------------------------------------------------------------------------------
        const _programFadeAway = new CG.glWrapper.Program(gl, CG.shaderSource.fadeAwayFromCamera.vs, CG.shaderSource.fadeAwayFromCamera.fs);
        const _meshGrid = new CG.Mesh(CG.Geometry.createGridPlane(100, 1).init(gl));
        const _pipe_grid = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setProgram(_programFadeAway)
            .setVAO(_meshGrid.VAO)
            .setUniformUpdater({
                updateu_mvpMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewProjectionMatrix._dataArr32);
                },
                updateu_mvMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewMatrix._dataArr32);
                }
            })
            .cullFace(true)
            .setDrawArraysParameters(gl.LINES, 0, _meshGrid.vertexDataLengthInFloat)
            .validate();




        //--------------------------------------------------------------------------------
        const _program = new CG.glWrapper.Program(gl, CG.shaderSource.gouraud.vs, CG.shaderSource.gouraud.fs);
        const _mesh = new CG.Mesh(CG.Geometry.createCube(4).init(gl)).setPosition(0, 0, 0);
        //const _mesh = new CG.Mesh(CG.Geometry.createPlane(4, 3).init(gl)).setPosition(0, 0, 0);

        const _pipe_cube = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setProgram(_program)
            .setVAO(_mesh.VAO)
            .setUniformUpdater(
                {
                    updateu_mvpMatrix: (uLoc) => {
                        _mesh.cascade(_camera.viewProjectionMatrix, _tempMat44);
                        gl.uniformMatrix4fv(uLoc, false, _tempMat44._dataArr32);
                    },
                    updateu_mMatrix: (uLoc) => {
                        _mesh.getTransform(_tempMat44);
                        gl.uniformMatrix4fv(uLoc, false, _tempMat44._dataArr32);
                    },
                    updateu_ambientColor: (uLoc) => {
                        gl.uniform4f(uLoc, 0.2, 0.2, 0.2, 1.0);
                    },
                    updateu_pointLightColor: (uLoc) => {
                        gl.uniform4f(uLoc, 0.5, 0.5, 0.5, 1.0);
                    },
                    updateu_pointLightPositionW: (uLoc) => {
                        gl.uniform3f(uLoc, 14.0, 14.0, 14.0);
                    },
                    updateu_cameraPositionW: (uLoc) => {
                        gl.uniform3f(uLoc, _camera.position.x, _camera.position.y, _camera.position.z);
                    },
                    updateu_alpha: (uLoc) => {
                        gl.uniform1f(uLoc, 40.0);
                    },
                })
            .setDrawElementsParameters(gl.TRIANGLES, _mesh.numberIndices, gl.UNSIGNED_SHORT, 0)
            .cullFace(true)
            .validate();
        _renderer.addPipeline(_pipe_grid, _pipe_cube);
        //--------------------------------------------------------------------------------





        function render() {
            _camera.update();

            _renderer.render();

            requestAnimationFrame(render);
        }

        render();

    </script>
</body>

</html>
