<!DOCTYPE html>
<html>

<head>
    <title>WebGL</title>
    <link rel="icon" href="./assets/favicon.png" type="image/x-icon">
    <style>
        body {
            margin: 0;
            background-color: #272727;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas" width="640" height="480"></canvas>
    <img id="color-texture" src="./assets/uv-grid.webp" crossOrigin="anonymous"></img>
    <script src="./src/log.js"></script>
    <script src="./src/math.js"></script>
    <script src="./src/gl.js"></script>
    <script src="./src/glsl.js"></script>
    <script src="./src/geometry.js"></script>
    <script src="./src/orthogonal-space.js"></script>
    <script src="./src/utils.js"></script>
    <script src="./src/mouse-events.js"></script>
    <script src="./src/space-controller.js"></script>
    <script src="./src/camera.js"></script>
    <script src="./src/frustum.js"></script>
    <script src="./src/mesh.js"></script>
    <script src="./glsl/fade-away-from-camera.js"></script>
    <script src="./glsl/only-texture.js"></script>
    <script>
        const _imgElement = document.getElementById("color-texture"); _imgElement.remove();
        const {gl, canvas} = CG.createGlContext('glcanvas');
        const _tempMat44 = new CG.Mat44();
        const _camera = new CG.Camera(0, 2, 8)
            .setMouseEvents(CG.registMouseEvents(canvas))
            .setFrustum(new CG.Frustum().createPerspectiveProjection(CG.Utils.deg2Rad(60), 640 / 480, 0.1, 1000))
            .lookAt(CG.Vec4.VEC4_0001);

        const _defaultFBO = new CG.glWrapper.Framebuffer(gl, false);





        //--------------------------------------------------------------------------------
        const _programFadeAway = new CG.glWrapper.Program(gl, CG.shaderSource.fadeAwayFromCamera.vs, CG.shaderSource.fadeAwayFromCamera.fs)
            .setUniformUpdater({
                updateu_mvpMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewProjectionMatrix._dataArr32);
                },
                updateu_mvMatrix: (uLoc) => {
                    gl.uniformMatrix4fv(uLoc, false, _camera.viewMatrix._dataArr32);
                }
            });
        const _meshGrid = new CG.Mesh(CG.Geometry.createGridPlane(100, 1).init(gl));




        //--------------------------------------------------------------------------------
        const _programTextureOnly = new CG.glWrapper.Program(gl, CG.shaderSource.onlyTexture.vs, CG.shaderSource.onlyTexture.fs).setUniformUpdater({
            updateu_mvpMatrix: (uLoc) => {
                _meshPlane.cascade(_camera.viewProjectionMatrix, _tempMat44);
                gl.uniformMatrix4fv(uLoc, false, _tempMat44._dataArr32);
            },
            updateu_texture: (uLoc) => {
                gl.uniform1i(uLoc, _colorTexture.textureUnit);
            }
        });
        const _meshPlane = new CG.Mesh(CG.Geometry.createPlane(4, 3).init(gl)).setPosition(0, 0, 0);
        const _colorTexture = new CG.glWrapper.Texture(gl).createGLTexture(_imgElement);
        //--------------------------------------------------------------------------------




        const _pipe_grid = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setVAO(_meshGrid.VAO)
            .setProgram(_programFadeAway)
            .setDrawArraysParameters(gl.LINES, 0, _meshGrid.vertexDataLengthInFloat)
            .validate();
        const _pipe_plane = new CG.glWrapper.Pipeline(gl)
            .setFBO(_defaultFBO)
            .setVAO(_meshPlane.VAO)
            .setProgram(_programTextureOnly)
            .setTextures(_colorTexture)
            .setDrawElementsParameters(gl.TRIANGLES, _meshPlane.numberIndices, gl.UNSIGNED_SHORT, 0)
            .validate();
        //--------------------------------------------------------------------------------





        function render() {
            _camera.update();


            gl.clearColor(0.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            _pipe_grid.execute();
            _pipe_plane.execute();


            requestAnimationFrame(render);
        }

        render();

    </script>
</body>

</html>
